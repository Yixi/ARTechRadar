<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>Name</key>
		<string>Lightweight Architecture Decision Records</string>
		<key>Number</key>
		<integer>1</integer>
		<key>Description</key>
		<string>Much documentation can be replaced with highly readable code and tests. In a world of evolutionary architecture, however, it&apos;s important to record certain design decisions for the benefit of future team members as well as for external oversight. Lightweight Architecture Decision Records is a technique for capturing important architectural decisions along with their context and consequences. We recommend storing these details in source control, instead of a wiki or website, as then they can provide a record that remains in sync with the code itself. For most projects, we see no reason why you wouldn&apos;t want to use this technique.</string>
		<key>Level</key>
		<string>ADOPT</string>
		<key>Quadrant</key>
		<string>Techniques</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>-0.08</real>
			<key>Z</key>
			<real>-0.1</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>Applying product management to internal platforms</string>
		<key>Number</key>
		<integer>2</integer>
		<key>Description</key>
		<string>We&apos;ve seen a steep increase in interest in the topic of digital platforms over the past 12 months. Companies looking to roll out new digital solutions quickly and efficiently are building internal platforms, which offer teams self-service access to the business APIs, tools, knowledge and support necessary to build and operate their own solutions. We find that these platforms are most effective when they&apos;re given the same respect as an external product offering. Applying product management to internal platforms means establishing empathy with internal consumers (read: developers) and collaborating with them on the design. Platform product managers establish roadmaps and ensure the platform delivers value to the business and enhances the developer experience. Some owners even create a brand identity for the internal platform and use that to market the benefits to their colleagues. Platform product managers look after the quality of the platform, gather usage metrics, and continuously improve it over time. Treating the platform as a product helps to create a thriving ecosystem and avoids the pitfall of building yet another stagnant, underutilized service-oriented architecture.</string>
		<key>Level</key>
		<string>TRIAL</string>
		<key>Quadrant</key>
		<string>Techniques</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>-0.1</real>
			<key>Z</key>
			<real>-0.22</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>DesignOps</string>
		<key>Number</key>
		<integer>7</integer>
		<key>Description</key>
		<string>Inspired by the DevOps movement, DesignOps is a cultural shift and a set of practices that allows people across an organization to continuously redesign products without compromising quality, service coherency or team autonomy. DesignOps advocates for the creation and evolution of a design infrastructure that minimizes the effort necessary to create new UI concepts and variations, and to establish a rapid and reliable feedback loop with end users. With tools such as Storybook promoting close collaboration, the need for upfront analysis and specification handoffs is reduced to the absolute minimum. With DesignOps, design is shifting from being a specific practice to being a part of everyone&apos;s job.</string>
		<key>Level</key>
		<string>TRIAL</string>
		<key>Quadrant</key>
		<string>Techniques</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>-0.23</real>
			<key>Z</key>
			<real>-0.2</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>Polycloud</string>
		<key>Number</key>
		<integer>17</integer>
		<key>Description</key>
		<string>The major cloud providers (Amazon, Microsoft and Google) are locked in an aggressive race to maintain parity on core capabilities while their products are differentiated only marginally. This is causing a few organizations to adopt a Polycloud strategy — rather than going ‘all-in’ with one provider, they are passing different types of workloads to different providers in a best-of-breed approach. This may involve, for example, putting standard services on AWS, but using Google for machine learning, Azure for .NET applications that use SQLServer, or potentially using the Ethereum Consortium Blockchain solution. This is different than a cloud-agnostic strategy of aiming for portability across providers, which is costly and forces lowest-common-denominator thinking. Polycloud instead focuses on using the best that each cloud offers.

</string>
		<key>Level</key>
		<string>ASSESS</string>
		<key>Quadrant</key>
		<string>Techniques</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>-0.28</real>
			<key>Z</key>
			<real>-0.28</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>CI theatre</string>
		<key>Number</key>
		<integer>22</integer>
		<key>Description</key>
		<string>We&apos;ve long been advocates of continuous integration (CI), and we were pioneers in building CI server programs to automatically build projects on check-ins. Used well, these programs run as a daemon process on a shared project mainline that developers commit to daily. The CI server builds the project and runs comprehensive tests to ensure the whole software system is integrated and is in an always-releasable state, thus satisfying the principles of continuous delivery. Sadly, many developers simply set up a CI server and falsely assume they are &quot;doing CI&quot; when in reality they miss out on all the benefits. Common failure modes include: running CI against a shared mainline but with infrequent commits, so integration isn&apos;t really continuous; running a build with poor test coverage; allowing the build to stay red for long periods; or running CI against feature branches which results in continuous isolation. The ensuing &quot;CI theatre&quot; might make people feel good, but would fail any credible CI certification test.</string>
		<key>Level</key>
		<string>HOLD</string>
		<key>Quadrant</key>
		<string>Techniques</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>-0.35</real>
			<key>Z</key>
			<real>-0.35</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>Google Cloud Platform</string>
		<key>Number</key>
		<integer>26</integer>
		<key>Description</key>
		<string>As Google Cloud Platform (GCP) has expanded in terms of available geographic regions and maturity of services, customers globally can now seriously consider it for their cloud strategy. In some areas, GCP has reached feature parity with its main competitor, Amazon Web Services, while in other areas it has differentiated itself — notably with accessible machine learning platforms, data engineering tools, and a workable Kubernetes as a service solution (GKE). In practice, our teams have nothing but praise for the developer experience working with the GCP tools and APIs.</string>
		<key>Level</key>
		<string>TRIAL</string>
		<key>Quadrant</key>
		<string>Platforms</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>-0.2</real>
			<key>Z</key>
			<real>0.1</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>Google Cloud Platform</string>
		<key>Number</key>
		<integer>30</integer>
		<key>Description</key>
		<string>As Google Cloud Platform (GCP) has expanded in terms of available geographic regions and maturity of services, customers globally can now seriously consider it for their cloud strategy. In some areas, GCP has reached feature parity with its main competitor, Amazon Web Services, while in other areas it has differentiated itself — notably with accessible machine learning platforms, data engineering tools, and a workable Kubernetes as a service solution (GKE). In practice, our teams have nothing but praise for the developer experience working with the GCP tools and APIs.</string>
		<key>Level</key>
		<string>TRIAL</string>
		<key>Quadrant</key>
		<string>Platforms</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>-0.2</real>
			<key>Z</key>
			<real>0.1</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>GKE</string>
		<key>Number</key>
		<integer>40</integer>
		<key>Description</key>
		<string>While the software development ecosystem is converging on Kubernetes as the orchestration platform for containers, running Kubernetes clusters remains operationally complex. GKE (Google Kubernetes Engine) is a managed Kubernetes solution for deploying containerized applications that alleviates the operational overhead of running and maintaining Kubernetes clusters. Our teams have had a good experience using GKE, with the platform doing the heavy lifting of applying security patches, monitoring and auto-repairing the nodes, and managing multicluster and multiregion networking. In our experience, Google&apos;s API-first approach in exposing platform capabilities, as well as using industry standards such as OAuth for service authorization, improve the developer experience. It&apos;s important to consider that GKE is under rapid development which, despite the developers&apos; best efforts to abstract consumers from underlying changes, has impacted us temporarily in the past. We&apos;re expecting continuous improvement around maturity of Infrastructure as code with Terraform on GKE and similar tools.</string>
		<key>Level</key>
		<string>ADOPT</string>
		<key>Quadrant</key>
		<string>Platforms</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>-0.25</real>
			<key>Z</key>
			<real>0.2</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>jsoniter</string>
		<key>Number</key>
		<integer>58</integer>
		<key>Description</key>
		<string>If you&apos;re looking for a JSON encoder/decoder with high performance in Go and Java, check out the open source jsoniter library. The library is compatible with the standard JSON encoding package in Go.</string>
		<key>Level</key>
		<string>TRIAL</string>
		<key>Quadrant</key>
		<string>Tools</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>0.2</real>
			<key>Z</key>
			<real>-0.2</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>Flow</string>
		<key>Number</key>
		<integer>65</integer>
		<key>Description</key>
		<string>Flow is a static type checker for JavaScript that allows you to add type checking across the codebase incrementally. Unlike Typescript, which is a different language, Flow can be added incrementally to an existing JavaScript codebase supporting the 5th, 6th and 7th editions of ECMAScript. We suggest adding Flow to your continuous integration pipeline, starting with the code that concerns you most. Flow adds to the clarity of the code, increases the reliability of refactoring and catches type-related bugs early during the build.</string>
		<key>Level</key>
		<string>HOLD</string>
		<key>Quadrant</key>
		<string>Tools</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>0.3</real>
			<key>Z</key>
			<real>-0.3</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>Yarn</string>
		<key>Number</key>
		<integer>76</integer>
		<key>Description</key>
		<string>Yarn is a new package manager that replaces the existing workflow for the npm client while remaining compatible with the npm registry. With the npm client, we may end up with a different tree structure under node_modules based on the order that dependencies are installed. This nondeterministic nature can cause &quot;works on my machine&quot; problems. By breaking the installation steps into resolution, fetching and linking, Yarn avoids these issues using deterministic algorithms and lockfiles and thus guarantees repeatable installations. We&apos;ve also seen significantly faster builds in our continuous integration (CI) environment because of Yarn caching all the packages it downloads.</string>
		<key>Level</key>
		<string>HOLD</string>
		<key>Quadrant</key>
		<string>Tools</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>0.3</real>
			<key>Z</key>
			<real>-0.1</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>ARKit&amp;ARCore</string>
		<key>Number</key>
		<integer>87</integer>
		<key>Description</key>
		<string>We&apos;ve seen a flurry of activity in mobile augmented reality much of it fueled by ARKit and ARCore, the native AR libraries used by Apple and Google, respectively. These libraries are bringing mobile AR technologies to the mainstream. However, the challenge will be for companies to find use cases that go beyond gimmicky and provide genuine solutions that actually enhance the user experience.</string>
		<key>Level</key>
		<string>ASSESS</string>
		<key>Quadrant</key>
		<string>Language&amp;Frameworks</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>0.3</real>
			<key>Z</key>
			<real>0.1</real>
		</dict>
	</dict>
	<dict>
		<key>Name</key>
		<string>CSS-In-JS</string>
		<key>Number</key>
		<integer>91</integer>
		<key>Description</key>
		<string>CSS in JS is a technique of writing CSS styling in the JavaScript programming language. This encourages a common pattern of writing the styling with the JavaScript component it applies to, co-locating presentational and logical concerns. The new players — including JSS, emotion and styled-components — rely on the tooling to translate the CSS-in-JS code to separate CSS stylesheets, to make them suitable for browser consumption. This is the second-generation approach to writing CSS in JavaScript and unlike the previous approaches doesn’t rely on in-line styles. That means it provides the benefit of supporting all CSS features, sharing of CSS using the npm ecosystem and utilization of components across multiple platforms. Our teams have found styled-components working well with component-based frameworks, such as React, and unit testing of CSS with jest-styled-components. This space is new and rapidly changing; the approach requires some effort for manual debugging of the generated class names in the browser, and it may not apply to some projects where the front-end architecture does not support reusing components and requires global styling.</string>
		<key>Level</key>
		<string>ASSESS</string>
		<key>Quadrant</key>
		<string>Language&amp;Frameworks</string>
		<key>Position</key>
		<dict>
			<key>X</key>
			<real>0.1</real>
			<key>Z</key>
			<real>0.3</real>
		</dict>
	</dict>
</array>
</plist>
